package Algorithms;

import java.util.ArrayList;

import Graph_Generator.Vertex;
import Graph_Generator.functionnode;
import Graph_Generator.graphEdge;
import Algorithms.findShortestPath;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Set;
import java.util.TreeMap;

/*
*   For the following code, we have used the pseudocode simplification algorithms defined by DZ and EG
*
*   Code is generated for Maryamsadat Jalalitabar
*   Algorithm is generated by Danyang Zheng
*   Algorithm is modified by Evrim Guler
*   Implementation is done by Evrim Guler
*
*   Feb 12th, 2018
*/

public class TuneUpNew {

	ArrayList<Vertex> substrateNodes;
	ArrayList<ArrayList<Vertex>> givenChain;
	ArrayList<graphEdge> graphEdges;
	ArrayList<functionnode> virtualNodes;
	String fileName;
	int bandWidth;
	int indexValue;
	TreeMap<Integer, ArrayList<Integer>> treemap;
	ArrayList<Integer> usedSub;
	int numOfGroups;

	// generate a constructor with mapped chain, substrate graph, virtual request,
	// and file name
	// public TuneUp(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex>
	// substrateGraph, ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs,
	// String file, int BW) {
	public TuneUpNew(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex> substrateGraph,
			ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs, String file, int BW,
			TreeMap<Integer, ArrayList<Integer>> treemapFinal, ArrayList<Integer> usedSubSFC, int numOfGroups) {
		this.bandWidth = BW;
		this.fileName = file;
		this.givenChain = mappedChain;
		this.graphEdges = Edges;
		this.substrateNodes = substrateGraph;
		this.virtualNodes = VNFs;
		this.treemap = treemapFinal;
		this.usedSub = usedSubSFC;
		this.numOfGroups = numOfGroups;
	}

	public ArrayList<Vertex> tuneUpAlgorithm() {

		int currentIndexValue = this.givenChain.size();

		Vertex currentHeadNode = this.givenChain.get(currentIndexValue).get(0);

		this.indexValue = 0;

		ArrayList<Vertex> connectedChain = getConvertedChainFromGroups(this.givenChain);

		while (currentHeadNode != null) {

			connectedChain = triangleTuneUp(substrateNodes, connectedChain, currentHeadNode, indexValue);

			currentHeadNode = null;

			if (this.indexValue == 1 && currentIndexValue > 0) {
				currentIndexValue--;
				currentHeadNode = this.givenChain.get(currentIndexValue).get(0);
			}
		}

		return connectedChain;

	}

	private ArrayList<Vertex> triangleTuneUp(ArrayList<Vertex> substrateNodes, ArrayList<Vertex> currentChain,
			Vertex currentNode, int yValue) {

		int indexOfCurrentNode = findIndexValueOfCurrentNode(currentChain, currentNode);

		Vertex previousNode = null;
		Vertex nextNode = null;

		if (indexOfCurrentNode > 0) {
			previousNode = currentChain.get(indexOfCurrentNode - 1);
		}

		if (indexOfCurrentNode < currentChain.size() - 1) {
			nextNode = currentChain.get(indexOfCurrentNode + 1);
		}

		findShortestPath shortestPath = new findShortestPath(this.substrateNodes, this.graphEdges, this.virtualNodes);

		double distance2Previous = 0;
		double distance2Next = 0;

		if (previousNode != null) {
			distance2Previous = findShortestPathFromSource2Destination(currentNode, previousNode, this.bandWidth);
		}

		if (nextNode != null) {
			distance2Next = findShortestPathFromSource2Destination(currentNode, nextNode, this.bandWidth);
		}

		double currentDistance = distance2Previous + distance2Next;

		ArrayList<Vertex> substrateCandidatesOfCurrentNode = substrateNeighborCandidates(currentNode, this.usedSub);

		Vertex savedCandidateNode = currentNode;

		for (Vertex candidate : substrateCandidatesOfCurrentNode) {

			distance2Previous = 0;
			distance2Next = 0;

			/*
			 * Please use your shortest path cost function to find the distance from one
			 * node to another node
			 */
			if (previousNode != null) {
				distance2Previous = findShortestPathFromSource2Destination(candidate, previousNode, this.bandWidth);
			}

			if (nextNode != null) {
				distance2Next = findShortestPathFromSource2Destination(candidate, nextNode, this.bandWidth);
			}

			double newCalculatedDistance = distance2Previous + distance2Next;

			if (newCalculatedDistance < currentDistance) {
				currentDistance = newCalculatedDistance;
				savedCandidateNode = candidate;

			}

		}

		currentChain = updateCurrentChainWithNewClosestNode(currentChain, savedCandidateNode, previousNode, nextNode,
				indexOfCurrentNode);

		return currentChain;
	}

	private ArrayList<Vertex> updateCurrentChainWithNewClosestNode(ArrayList<Vertex> currentChain, Vertex candidate,
			Vertex previousNode, Vertex nextNode, int indexOfCurrentNode) {

		ArrayList<Vertex> previousChain = new ArrayList<Vertex>();
		ArrayList<Vertex> nextChain = new ArrayList<Vertex>();

		for (int index = 0; index < indexOfCurrentNode; index++) {
			previousChain.add(currentChain.get(index));
		}

		for (int index = indexOfCurrentNode + 1; index < currentChain.size(); index++) {
			nextChain.add(currentChain.get(index));
		}

		/*
		 * Please define or use your current path function for getShortestPath from one
		 * node to another node
		 */
		ArrayList<Vertex> path2PreviousNode = getShortestPathFromSource2Destination(candidate, previousNode,
				this.bandWidth);
		ArrayList<Vertex> path2NextNode = getShortestPathFromSource2Destination(candidate, nextNode, this.bandWidth);

		previousChain.addAll(path2PreviousNode);
		path2NextNode.remove(0);
		previousChain.addAll(path2NextNode);
		previousChain.addAll(nextChain);

		return previousChain;
	}

	private int findIndexValueOfCurrentNode(ArrayList<Vertex> currentChain, Vertex currentNode) {

		int indexValue = 0;

		for (int index = 0; index < currentChain.size(); index++) {

			if (currentChain.get(index).getNumber() == currentNode.getNumber()) {
				indexValue = index;
			}
		}

		return indexValue;
	}

	// private ArrayList<Vertex> substrateNeighborCandidates(ArrayList<Vertex>
	// currentNode, ArrayList<Vertex> substrateNodes){

	private ArrayList<Vertex> substrateNeighborCandidates(Vertex currentNode, ArrayList<Integer> usedSubSFC) {

		System.out.println("currentNode+ " + currentNode.getNumber());
		ArrayList<Vertex> substrateNeighbors = new ArrayList<Vertex>();
		Set<Integer> keys = this.treemap.keySet();// defined to provide an access to the functionodes and their
													// candidates
		for (Integer r : keys) {
			if (r == currentNode.getOfferedFunc().get(0)) {
				for (Integer s : this.treemap.get(r)) {
					if (!usedSubSFC.contains(s)) {
						substrateNeighbors.add(this.substrateNodes.get(s));
					}
				}

			}
		}

		return substrateNeighbors;
	}

	private ArrayList<Vertex> getConvertedChainFromGroups(ArrayList<ArrayList<Vertex>> currentChain) {

		ArrayList<Vertex> chainWithOutGroups = new ArrayList<Vertex>();

		for (ArrayList<Vertex> group : currentChain) {

			for (Vertex currentNode : group) {

				chainWithOutGroups.add(currentNode);
			} // end-for group

		} // end-for currentChain

		return chainWithOutGroups;
	}

	public ArrayList<ArrayList<Vertex>> getTunedUpGivenChain() {
		return givenChain;
	}
}
