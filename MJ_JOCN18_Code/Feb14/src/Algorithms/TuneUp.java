package Algorithms;

import java.util.ArrayList;

import Graph_Generator.Vertex;
import Graph_Generator.functionnode;
import Graph_Generator.graphEdge;
import Algorithms.findShortestPath;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Set;
import java.util.TreeMap;


/*
*   For the following code, we have used the pseudocode simplification algorithms defined by DZ and EG
*
*   Code is generated for Maryamsadat Jalalitabar
*   Algorithm is generated by Danyang Zheng
*   Algorithm is modified by Evrim Guler
*   Implementation is done by Evrim Guler
*
*   Feb 12th, 2018
*/

public class TuneUp {

    ArrayList<Vertex> substrateNodes;
    ArrayList<ArrayList<Vertex>> givenChain;
    ArrayList<graphEdge> graphEdges;
    ArrayList<functionnode> virtualNodes;
    String fileName;
    int bandWidth;
    int indexValue;
    TreeMap<Integer, ArrayList<Integer>> treemap;
    ArrayList<Integer> usedSub;
    int numOfGroups;
    
    // generate a constructor with mapped chain, substrate graph, virtual request, and file name
    // public TuneUp(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex> substrateGraph, ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs, String file, int BW) {
    public TuneUp(ArrayList<ArrayList<Vertex>> mappedChain, ArrayList<Vertex> substrateGraph, ArrayList<graphEdge> Edges, ArrayList<functionnode> VNFs, String file, int BW,
            
            TreeMap<Integer, ArrayList<Integer>> treemapFinal,ArrayList<Integer> usedSubSFC, int numOfGroups) {
        this.bandWidth = BW;
        this.fileName = file;
        this.givenChain = mappedChain;
        this.graphEdges = Edges;
        this.substrateNodes = substrateGraph;
        this.virtualNodes = VNFs;
        this.treemap=treemapFinal;
        this.usedSub=usedSubSFC;
        this.numOfGroups = numOfGroups;
    }

    public void tuneUpAlgorithm() {
        System.out.println("*********************************In tuneUpAlgorithm****************************************");
        System.out.println("usedSubSFC: " + this.usedSub);
       System.out.println("The number of groups:\t" + this.givenChain.size());
        System.out.println("The number of groups:\t" + this.numOfGroups);
        for (int i = 0; i < this.givenChain.size(); i++) {
            for (int j = 0; j < this.givenChain.get(i).size(); j++) {  
                
                System.out.println("mappedChain: " + i + " Current element: " + this.givenChain.get(i).get(j).getNumber() );              
            }
            System.out.println("**********************************");           
        }

         Set<Integer> keys2 = this.treemap.keySet();//defined to provide an access to the functionodes
            System.out.println("*****************************************************");
            System.out.println("checking the treemap" + this.treemap);
            System.out.println("*****************************************************");
            System.out.println("checking the treemap keys: " + Arrays.toString(keys2.toArray()));
            System.out.println("*****************************************************");
            for (Integer r : keys2) {
                System.out.println("keys of the treemap: " + r + " plus its list " + this.treemap.get(r));
            }       
                
        ArrayList<Vertex> ingressNodes = new ArrayList<Vertex>();
        ArrayList<Vertex> egressNodes = new ArrayList<Vertex>();

        int maxGroupValue = this.numOfGroups - 1;
      //  int maxGroupValue = this.givenChain.size() - 1;
        ArrayList<Vertex> currentNode = new ArrayList<Vertex>();
        this.indexValue = 0;

        // set all ingress and egress nodes for each group
        for (ArrayList<Vertex> group : this.givenChain) {
            if (group.size()>0) {
                System.out.println("group.get(0) :" + group.size());
                ingressNodes.add(group.get(0));
                egressNodes.add(group.get(group.size() - 1));
            }
        } // end-for

        
        currentNode.add(givenChain.get(maxGroupValue).get(0));

        while (currentNode.size()>0 && currentNode!=null){
            this.givenChain = triangleTuneUp(this.substrateNodes, this.givenChain, currentNode, this.indexValue);

            if (this.indexValue == 1){
                currentNode.clear();
                currentNode.add(this.givenChain.get(maxGroupValue-1).get(0));
                this.indexValue = 0;

                if (maxGroupValue == 0){
                    // what kind of node mapping process we have here???
                    currentNode.clear();
                    currentNode.add(givenChain.get(0).get(0));
                } // end-if maxGroupValue = 0
            }
            else {

                Vertex cNode = currentNode.get(0);
                currentNode.clear();
                // which node we need to add in CNode???
                ArrayList<Vertex> currentFullChain = getConvertedChainFromGroups(this.givenChain);

                currentNode.add(currentFullChain.get(currentFullChain.indexOf(cNode)));


            } // end-if-else this.indexValue = 1

        } // end-while

    }

    private ArrayList<ArrayList<Vertex>> triangleTuneUp(ArrayList<Vertex> substrateNodes, ArrayList<ArrayList<Vertex>> currentChain, ArrayList<Vertex> currentNode, int yValue){

        double currentDistance = Double.POSITIVE_INFINITY;

        ArrayList<Vertex> nodeSetOfP = new ArrayList<Vertex>();
        nodeSetOfP.addAll(currentNode);


        ArrayList<Vertex> substrateNeighborCandidates = substrateNeighborCandidates(currentNode, this.usedSub);//this method needs to take pruned graph info
        ArrayList<Vertex> chainWithOutGroup = getConvertedChainFromGroups(currentChain);

        for (Vertex currentNeighborCandidate: substrateNeighborCandidates) {

            findShortestPath shortestPath = new findShortestPath(nodeSetOfP, graphEdges, virtualNodes);
            
            ArrayList<Vertex> nodes = new ArrayList<Vertex>();
            nodes.add(currentNeighborCandidate);
            
            ArrayList<Integer> shortestToNext;
            if (chainWithOutGroup.indexOf(currentNode.get(0))!=chainWithOutGroup.size()-1) {
                shortestToNext= shortestPath.findShortest(nodes, chainWithOutGroup.get(chainWithOutGroup.indexOf(currentNode.get(0))+1),this.bandWidth);
            }else{
                shortestToNext = null;
            }
            double distance2NextNode = .0;
            if (shortestToNext!=null) {
                distance2NextNode =shortestToNext.size()-1;
            }
//            ArrayList<Integer> shortestToNext=shortestPath.findShortest(nodes, chainWithOutGroup.get(chainWithOutGroup.indexOf(currentNode.get(0))+1),this.bandWidth);            
//            double distance2NextNode = shortestToNext.size()-1;

            System.out.println("SFC chain without groups:\t"+chainWithOutGroup.get(0).getNumber());
            ArrayList<Integer> shortestToPre;
            if (chainWithOutGroup.indexOf(currentNode.get(0))!=0) {
                shortestToPre= shortestPath.findShortest(nodes, chainWithOutGroup.get(chainWithOutGroup.indexOf(currentNode.get(0))-1),this.bandWidth);
            }else{
                shortestToPre = null;
            }
            double distance2PreviousNode = .0;
            if (shortestToPre!=null) {
                distance2PreviousNode =shortestToPre.size()-1;
            }
            

            double newTotalDistance = distance2NextNode + distance2PreviousNode;

            if (newTotalDistance<currentDistance){
                currentDistance = newTotalDistance;
                nodeSetOfP.clear();
                nodeSetOfP.addAll(substrateNeighborCandidates);
            } // end-if distance check
            
            nodes.clear();

        } // end-for checking neighbor candidates

        if (nodeSetOfP.get(0).getNumber()==currentNode.get(0).getNumber()){
            this.indexValue = 1;
        } // end-if P is equal to CNode
        else{
            nodeSetOfP.clear();
            nodeSetOfP.addAll(currentNode);
        }

        return this.givenChain;
    }

    //private ArrayList<Vertex> substrateNeighborCandidates(ArrayList<Vertex> currentNode, ArrayList<Vertex> substrateNodes){
    
    private ArrayList<Vertex> substrateNeighborCandidates(ArrayList<Vertex> currentNode,ArrayList<Integer> usedSubSFC){
        
        System.out.println("currentNode+ " + currentNode.get(0).getNumber());
        ArrayList<Vertex> substrateNeighbors = new ArrayList<Vertex>();
        Set<Integer> keys = this.treemap.keySet();//defined to provide an access to the functionodes and their candidates   
        for (Integer r : keys) {           
            if(r==currentNode.get(0).getOfferedFunc().get(0)){
                 for (Integer s : this.treemap.get(r)) {       
                    if (!usedSubSFC.contains(s)){
                       substrateNeighbors.add(this.substrateNodes.get(s));
                    } 
                }
                
            }
            }
       
        return substrateNeighbors;
    }

    private ArrayList<Vertex> getConvertedChainFromGroups(ArrayList<ArrayList<Vertex>> currentChain){

        ArrayList<Vertex> chainWithOutGroups = new ArrayList<Vertex>();

        for (ArrayList<Vertex> group: currentChain) {

            for (Vertex currentNode: group) {

                chainWithOutGroups.add(currentNode);
            } // end-for group

        } // end-for currentChain

        return chainWithOutGroups;
    }


    public ArrayList<ArrayList<Vertex>> getTunedUpGivenChain() {
        return givenChain;
    }
}
